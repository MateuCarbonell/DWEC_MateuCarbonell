const canvas = document.getElementById("tetris");
const lienzo = canvas.getContext("2d");

const filas = 20;
const columnas = 10;
const tamCelda = 30; // Tamaño de cada celda en píxeles

// Crear el tablero vacío
let tablero = [];
for (let i = 0; i < filas; i++) {
    tablero.push(new Array(columnas).fill(0)); // Cada fila llena de 0
}

// Definición de piezas
const piezas = [
    { nombre: "C", forma: [[1, 1, 1], [1, 0, 1]], probabilidad: 0.2, color: "red" },
    { nombre: "L", forma: [[1, 0, 0], [1, 1, 1]], probabilidad: 0.2, color: "blue" },
    { nombre: "T", forma: [[0, 1, 0], [1, 1, 1]], probabilidad: 0.2, color: "purple" },
    { nombre: "Z", forma: [[1, 1, 0], [0, 1, 1]], probabilidad: 0.2, color: "green" },
    { nombre: "O", forma: [[1, 1], [1, 1]], probabilidad: 0.2, color: "yellow" }
];

// Dibujar el tablero
function dibujarTablero() {
    for (let fila = 0; fila < filas; fila++) {
        for (let columna = 0; columna < columnas; columna++) {
            const x = columna * tamCelda;
            const y = fila * tamCelda;
            lienzo.fillStyle = tablero[fila][columna] === 1 ? "gray" : "black";
            lienzo.fillRect(x, y, tamCelda, tamCelda);
            lienzo.strokeStyle = "white";
            lienzo.strokeRect(x, y, tamCelda, tamCelda);
        }
    }
}

// Dibujar una pieza
function dibujarPieza(pieza, x, y) {
    for (let fila = 0; fila < pieza.forma.length; fila++) {
        for (let columna = 0; columna < pieza.forma[fila].length; columna++) {
            if (pieza.forma[fila][columna] === 1) {
                const celdaX = x + columna * tamCelda;
                const celdaY = y + fila * tamCelda;
                lienzo.fillStyle = pieza.color;
                lienzo.fillRect(celdaX, celdaY, tamCelda, tamCelda);
                lienzo.strokeStyle = "white";
                lienzo.strokeRect(celdaX, celdaY, tamCelda, tamCelda);
            }
        }
    }
}

// Generar una pieza aleatoria
function generarPieza() {
    const random = Math.random();
    let acumulado = 0;
    for (let i = 0; i < piezas.length; i++) {
        acumulado += piezas[i].probabilidad;
        if (random <= acumulado) return piezas[i];
    }
    return piezas[piezas.length - 1];
}

// Posicionar pieza en el tablero
function posicionarPieza(pieza, x, y) {
    for (let fila = 0; fila < pieza.forma.length; fila++) {
        for (let columna = 0; columna < pieza.forma[fila].length; columna++) {
            if (pieza.forma[fila][columna] === 1) {
                tablero[y + fila][x + columna] = 1;
            }
        }
    }
}

// Eliminar líneas completas
function eliminarLinea() {
    for (let fila = filas - 1; fila >= 0; fila--) {
        if (tablero[fila].every(celda => celda === 1)) {
            tablero.splice(fila, 1);
            tablero.unshift(new Array(columnas).fill(0));
        }
    }
}

// Chequear colisiones
function chequearColisiones(pieza, x, y) {
    for (let fila = 0; fila < pieza.forma.length; fila++) {
        for (let columna = 0; columna < pieza.forma[fila].length; columna++) {
            if (pieza.forma[fila][columna] === 1) {
                const tableroX = x + columna;
                const tableroY = y + fila;
                if (tableroX < 0 || tableroX >= columnas || tableroY >= filas || tablero[tableroY][tableroX] === 1) {
                    return true;
                }
            }
        }
    }
    return false;
}

// Actualizar el juego
function actualizar() {
    if (!chequearColisiones(piezaActiva, posicionPieza.x, posicionPieza.y + 1)) {
        posicionPieza.y++;
    } else {
        posicionarPieza(piezaActiva, posicionPieza.x, posicionPieza.y);
        eliminarLinea();
        piezaActiva = generarPieza();
        posicionPieza = { x: Math.floor(columnas / 2) - 1, y: 0 };
        if (chequearColisiones(piezaActiva, posicionPieza.x, posicionPieza.y)) {
            alert("Fin del juego. ¡Gracias por jugar!");
            clearInterval(juegoIntervalo);
        }
    }
    lienzo.clearRect(0, 0, canvas.width, canvas.height);
    dibujarTablero();
    dibujarPieza(piezaActiva, posicionPieza.x * tamCelda, posicionPieza.y * tamCelda);
}

// Manejo de teclado
document.addEventListener("keydown", event => {
    if (event.key === "a" && !chequearColisiones(piezaActiva, posicionPieza.x - 1, posicionPieza.y)) {
        posicionPieza.x--;
    } else if (event.key === "d" && !chequearColisiones(piezaActiva, posicionPieza.x + 1, posicionPieza.y)) {
        posicionPieza.x++;
    } else if (event.key === "s" && !chequearColisiones(piezaActiva, posicionPieza.x, posicionPieza.y + 1)) {
        posicionPieza.y++;
    }
    lienzo.clearRect(0, 0, canvas.width, canvas.height);
    dibujarTablero();
    dibujarPieza(piezaActiva, posicionPieza.x * tamCelda, posicionPieza.y * tamCelda);
});

// Iniciar el juego
let piezaActiva = generarPieza();
let posicionPieza = { x: Math.floor(columnas / 2) - 1, y: 0 };
dibujarTablero();
dibujarPieza(piezaActiva, posicionPieza.x * tamCelda, posicionPieza.y * tamCelda);

const juegoIntervalo = setInterval(actualizar, 500); // Actualización cada 500ms
